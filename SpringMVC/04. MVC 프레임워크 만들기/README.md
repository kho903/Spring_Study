# 프론트 컨트롤러 패턴 소개
## FrontController 패턴 특징
- 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음
- 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출
- 입구를 하나로!
- 공통 처리 기능
- 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨

## 스프링 웹 MVC와 프론트 컨트롤러
- 스프링 웹 MVC의 핵심도 바로 FrontController
- 스프링 웹 MVC의 DispatcherServlet이 FrontController 패턴으로 구현되어 있음

# Model 추가 - v3
## 서블릿 종속성 제거
- 컨트롤러 입장에서 HttpServletRequest, HttpServletResponse가 꼭 필요할까?
- 요청 파라미터 정보는 자바의 Map으로 대신 넘기도록 하면 지금 구조에서는 컨트롤러가 서블릿 기술을 몰라도 동작할 수 있다.
- 그리고 request 객체를 Model로 사용하는 대신에 별도의 Model 객체를 만들어서 반환하면 된다.
- 우리가 구현하는 컨트롤러가 서블릿 기술을 전혀 사용하지 않도록 변경하자 -> 구현코드 단순 / 테스트 코드 작성 용이

## 뷰 이름 중복 제거
- 컨트롤러에서 지정하는 뷰 이름에 중복이 있는 것을 확인할 수 있다.
- 컨트롤러는 뷰의 논리 이름을 반환하고, 실제 물리 위치의 이름은 프론트 컨트롤러에서 처리하도록 단순화한다.
- 이렇게 해두면 향후 뷰의 폴더위치가 함께 이동해도 프론트 컨트롤러만 고치면 된다.

## ModelView
- 지금까지 컨트롤러에서 서블릿에 종속적인 HttpServletRequest를 사용했다. 그리고 Model도 `request.setAttribut()`를 통해 데이터를 저장하고 뷰에 전달했다.
- 서블릿의 종속성을 제거하기 위해 Model을 직접 만들고, 추가로 View 이름까지 전달하는 객체를 만들자.
- (이번 버전에서는 컨트롤러에서 HttpServletRequest를 사용할 수 없다. 따라서 직접 `request.setAttribute()`를 호출할 수도 없다. 따라서 Model이 별도로 필요하다.)
- 참고로 'ModelView' 객체는 다른 버전에서도 사용하므로 패키지를 'frontcontroller'에 둔다.

# 단순하고 실용적인 컨트롤러 - v4
- 앞서 만든 v3 컨트롤러는 서블릿 종속성을 제거하고 뷰 경로의 중복을 제거하는 등, 잘 설계된 컨트롤러
- but, 실제 컨트롤러 인터페이스를 구현하는 개발자 입장에서 보면, 항상 ModelView 객체를 생성하고 반환해야 하는 부분이 조금은 번거롭다.
- 좋은 프레임워크는 아키텍처도 중요하지만, 그와 더불어 실제 개발하는 개발자가 단순하고 편리하게 사용할 수 있어야 한다.(실용성이 있어야 한다.)
- 개발자가 더 편리하게 개발할 수 있는 v4

## v4 정리
- v4 컨트롤러는 매우 단순하고 실용적
- 기존 구조에서 모델을 파라미터로 넘기고, 뷰의 논리 이름을 반환한다는 작은 아이디어를 적용했을 뿐인데, 컨트롤러를 구현하는 개발자 입장에서 보면 이제 군더더기 없는 코드를 작성할 수 있다.
- 또한 중요한 사실은 여기까지 한번에 온것이 아니라는 점.
- 프레임워크가 점진적으로 발전하는 과정 속에서 이런 방법도 찾을 수 있었다.
- 프레임워크나 공통 기능이 수고로워야 사용하는 개발자가 편리해진다.

# 유연한 컨트롤러1 - v5
- 다양한 종류의 컨트롤러를 쓰고 싶을 땐, 어떻게 해야 하나?

## 어댑터 패턴
- 지금까지 우리가 개발한 프론트 컨트롤러는 한 가지 방식의 컨트롤러 인터페이스만 사용가능
- 다른 컨트롤러 인터페이스 호환 불가능 (110v, 220v 처럼 -> 어댑터와 같은 것으로 해결)
- 어댑터 패턴을 사용해서 프론트 컨트롤러가 다양한 방식의 컨트롤러를 처리할 수 있도록 변경해보자.

### 핸들러 어댑터
- 중간에 어댑터 역할을 하는 어댑터가 추가되었는데 이름이 핸들러 어댑터이다.
- 여기서 어댑터 역할을 해주는 덕분에 다양한 종류의 컨트롤러를 호출할 수 있다.

### 핸들러
- 컨트롤러의 이름을 더 넓은 범위인 핸들러로 변경
- 이제 어댑터가 있기 때문에 꼭 컨트롤러의 개념 뿐만 아니라 어떠한 것이든 해당하는 종류의 어댑터만 있으면 다 처리할 수 있기 때문.

### 컨트롤러(Controller) -> 핸들러(Handler)
- 이전에는 컨트롤러를 직접 매핑해서 사용했다.
- 이제는 어댑터를 이용하기 때문에, 컨트롤러 뿐만 아니라 어댑터가 지원하기만 하면, 어떤 것이라도 URL에 매핑해서 사용할 수 있다.
- 그래서 이름을 컨트롤러에서 더 넓은 범위의 핸들러로 변경했다.

# 정리
- v1 : 프론트 컨트롤러 도입
    - 기존 구조를 최대한 유지하면서 프론트 컨트롤러를 도입
- v2 : View 분류
    - 단순 반복되는 뷰 로직 분리
- v3 : Model 추가
    - 서블릿 종속성 제거
    - 뷰 이름 중복 제거
- v4 : 단순하고 실용적인 컨트롤러
    - v3와 거의 비슷
    - 구현 입장에서 ModelView를 직접 생성해서 반환하지 않도록 편리한 인터페이스 제공
- v5 : 유연한 컨트롤러
    - 어댑터 도입
    - 어댑터를 추가해서 프레임워크를 유연하고 확장성 있게 설계
- 여기에 애노테이션을 사용해서 컨트롤러를 더 편리하게 발전시킬 수 있다.
- 만약 애노테이션을 사용해서 컨트롤러를 편리하게 사용하고 싶으면, 애노테이션을 지원하는 어댑터를 추가하면 된다.
- 다형성과 어댑터 덕분에 기존 구조를 유지하면서, 프레임워크 기능을 확장할 수 있다.
- 스프링 MVC에는 지금까지 우리가 학습한 내용과 거의 같은 구조를 가지고 있다.
2