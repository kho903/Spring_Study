# 검증 직접 처리 - 개발
## 검증 오류 보관
- `Map<String, String> errors = new HashMap<>();`
- 만약 검증 시 오류가 발생하면 어떤 검증에서 오류가 발생했는 지 정보를 담아둔다.
- `import org.springframework.util.StringUtils;` 추가 필요
    - 검증 시 오류가 발생하면 errors에 담아둔다.
    - 이 때 어떤 필드에서 오류가 발생했는 지 구분하기 위해 오류가 발생한 필드명을 key로 사용한다.
    - 이 후 뷰에서 이 데이터를 사용해서 친절한 오류 메시지를 출력할 수 있다.
- 검증에서 오류가 하나라도 있으면 오류 메시지를 출력하기 위해 `model`, `errors`를 담고, 입력 폼이 있는 뷰를 템플릿으로 보낸다.
- 오류 메시지는 errors에 내용이 있을 때만 출력하면 된다.
    - 타임리프의 th:if 를 사용하면 조건에 만족할 때만 해당 HTML 태그를 출력할 수 있다.

### 참고 : Safe Navigation Operator
- 만약 여기에서 `errors`가 `null`이면 어떻게 될까?
- `errors.containsKey()`를 호출하는 순간 `NullPointerException`이 발생한다.
- `errors?.`은 `errors`가 `null`일 때 `NullPointerException`이 발생하는 대신, `null`을 반환하는 문법이다.
- `th:if`에서 `null`은 실패로 처리되므로 오류 메시지가 출력되지 않는다.
- 이것은 SpringEL이 제공하는 문법이다.

### 정리
- 만약 검증 오류가 발생하면 입력 폼을 다시 보여준다.
- 검증 오류들을 고객에게 친절하게 안내해서 다시 입력할 수 있게 한다.
- 검증 오류가 발생해도 고객이 입력한 데이터가 유지된다.

### 남은 문제점
- 뷰 템플릿에서 중복 처리가 많다.
- 타입 오류 처리 아직 X. `Item`의 `price`, `quantity` 같은 숫자 필드는 타입이 `Integer`이므로 문자 타입으로 설정하는 것이 불가능하다.
숫자 타입에 문자가 들어오면 오류가 발생한다. 그런데 이러한 오류는 스프링MVC에서 컨트롤러에 진입하기도 전에 예외가 발생하기 때문에,
컨트롤러가 호출되지도 않고, 400예외가 발생하면서 오류 페이지를 띄워준다.
- `Item`의 `price`에 문자를 입력하는 것처럼 타입오류가 발생해도 고객에 입력한 문자를 화면에 남겨야 한다.
만약 컨트롤러가 호출된다고 가정해도 `Item`의 `price`는 `Integer`이므로 문자를 보관할 수가 없다.
결국 문자는 바인딩이 불가능하므로 고객이 입력한 문자가 사라지게 되고, 고객은 본인이 어떤 내용을 입력해서 오류가 발생했는지도 이해하기 어렵다.
- 결국 고객이 입력한 값도 어딘가에 별도로 관리가 되어야 한다.
